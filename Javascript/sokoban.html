<!DOCTYPE html>
<html>
  <head>
    <title>Sokoban OOP - Responsive & Touch (Auto Level)</title>
    <meta charset="UTF-8" />
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
      }

      #game {
        width: 100vw;
        height: 100vh;
        touch-action: none; /* Để ngăn cuộn trang khi tương tác trên mobile */
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>

    <script>
const levels = [
        // Level 1 - Basic movement (5x5)
`
#######
###   #
#.@$  #
### $.#
#.##$ #
# # . ##
#$ *$$.#
#   .  #
########`,
        // Level 2 - Dual boxes (6x5)
        `
######
#@   #
# $$ #
# .. #
######
        `,
        // Level 3 - Corridor navigation (7x5)
        `
#######
#     #
# @$  #
#  .  #
#######
        `,
        // Level 4 - Corner push (7x5)
        `
#######
#.@  #
# $  #
#   .#
#######
        `,
        // Level 5 - Wall navigation (5x5)
        `
#####
#   #
##$@#
# . #
#####
        `,
        // Level 6 - Multiple paths (8x5)
        `
########
#  @  ##
# $$  ##
#..   ##
########
        `,
        // Level 7 - Symmetric challenge (9x5)
        `
#########
#   @   #
# $   $ #
# .   . #
#########
        `,
        // Level 8 - Maze puzzle (8x6)
        `
########
# ###  #
# $ @  #
# .##  #
#  .   #
########
        `,
        // Level 9 - Advanced (10x6)
        `
##########
#  ####  #
# $  $   #
##@  ##  #
# ..##   #
##########
        `,
        // Level 10 - Expert (10x6)
        `
##########
#  ####  #
# $    $ #
#  .  .  #
#   ##   #
##########
        `
      ].map(level => level.trim());

      // -------------------------
      // Lớp Level: Quản lý dữ liệu level và vẽ lớp tĩnh (walls & goal) và các đối tượng động (block)
      // -------------------------
      class Level {
        constructor(levelString, grid) {
          this.grid = grid;
          this.types = {
            wall: "#",
            player: "@",
            playerOnGoal: "+",
            block: "$",
            blockOnGoal: "*",
            goal: ".",
            empty: " ",
          };
          this.cells = [];
          this.width = 0;
          this.playerStart = { row: 0, col: 0 };
          this.loadLevel(levelString);
        }

        loadLevel(levelString) {
          const rows = levelString
            .split("\n")
            .filter((row) => row.trim().length > 0);
          rows.forEach((rowData, row) => {
            this.cells[row] = [];
            if (rowData.length > this.width) {
              this.width = rowData.length;
            }
            rowData.split("").forEach((colData, col) => {
              this.cells[row][col] = colData;
              if (
                colData === this.types.player ||
                colData === this.types.playerOnGoal
              ) {
                this.playerStart = { row, col };
              }
            });
          });
        }

        // Di chuyển một entity từ startPos sang endPos
        moveEntity(startPos, endPos) {
          const startCell = this.cells[startPos.row][startPos.col];
          const endCell = this.cells[endPos.row][endPos.col];
          const isPlayer =
            startCell === this.types.player ||
            startCell === this.types.playerOnGoal;

          // Xóa entity khỏi ô cũ
          switch (startCell) {
            case this.types.player:
            case this.types.block:
              this.cells[startPos.row][startPos.col] = this.types.empty;
              break;
            case this.types.playerOnGoal:
            case this.types.blockOnGoal:
              this.cells[startPos.row][startPos.col] = this.types.goal;
              break;
          }

          // Đưa entity vào ô mới
          switch (endCell) {
            case this.types.empty:
              this.cells[endPos.row][endPos.col] = isPlayer
                ? this.types.player
                : this.types.block;
              break;
            case this.types.goal:
              this.cells[endPos.row][endPos.col] = isPlayer
                ? this.types.playerOnGoal
                : this.types.blockOnGoal;
              break;
          }
        }

        // Kiểm tra hoàn thành level (tất cả block đã trên goal)
        isComplete() {
          for (let row = 0; row < this.cells.length; row++) {
            for (let col = 0; col < this.cells[row].length; col++) {
              if (this.cells[row][col] === this.types.block) {
                return false;
              }
            }
          }
          return true;
        }

        // Tạo static layer: vẽ tường và goal lên offscreen canvas
        createStaticLayer(grid, wallCanvas) {
          const off = document.createElement("canvas");
          off.width = this.width * grid;
          off.height = this.cells.length * grid;
          const ctx = off.getContext("2d");
          for (let row = 0; row < this.cells.length; row++) {
            for (let col = 0; col < this.cells[row].length; col++) {
              const cell = this.cells[row][col];
              if (cell === this.types.wall) {
                ctx.drawImage(wallCanvas, col * grid, row * grid, grid, grid);
              }
              if (
                cell === this.types.goal ||
                cell === this.types.playerOnGoal ||
                cell === this.types.blockOnGoal
              ) {
                ctx.fillStyle = "#914430";
                ctx.beginPath();
                ctx.arc(
                  (col + 0.5) * grid,
                  (row + 0.5) * grid,
                  grid * 0.15,
                  0,
                  Math.PI * 2
                );
                ctx.fill();
              }
            }
          }
          return off;
        }

        // Vẽ các đối tượng động (block) lên canvas
        drawDynamic(ctx, grid) {
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          for (let row = 0; row < this.cells.length; row++) {
            for (let col = 0; col < this.cells[row].length; col++) {
              const cell = this.cells[row][col];
              if (
                cell === this.types.block ||
                cell === this.types.blockOnGoal
              ) {
                ctx.fillStyle =
                  cell === this.types.block ? "#ffbb5b" : "#ba6a15";
                ctx.fillRect(col * grid, row * grid, grid, grid);
                ctx.strokeRect(col * grid, row * grid, grid, grid);
                ctx.strokeRect(
                  (col + 0.1) * grid,
                  (row + 0.1) * grid,
                  grid - 0.2 * grid,
                  grid - 0.2 * grid
                );
                ctx.beginPath();
                ctx.moveTo((col + 0.1) * grid, (row + 0.1) * grid);
                ctx.lineTo((col + 0.9) * grid, (row + 0.9) * grid);
                ctx.moveTo((col + 0.9) * grid, (row + 0.1) * grid);
                ctx.lineTo((col + 0.1) * grid, (row + 0.9) * grid);
                ctx.stroke();
              }
            }
          }
        }
      }

      // -------------------------
      // Lớp Player: Quản lý vị trí, di chuyển và vẽ người chơi
      // -------------------------
      class Player {
        constructor(startPos) {
          this.pos = { row: startPos.row, col: startPos.col };
        }

        move(dir, level) {
          const newRow = this.pos.row + dir.row;
          const newCol = this.pos.col + dir.col;
          const cell = level.cells[newRow][newCol];
          switch (cell) {
            case level.types.empty:
            case level.types.goal:
              level.moveEntity(this.pos, { row: newRow, col: newCol });
              this.pos = { row: newRow, col: newCol };
              break;
            case level.types.wall:
              break;
            case level.types.block:
            case level.types.blockOnGoal:
              const nextRow = newRow + dir.row;
              const nextCol = newCol + dir.col;
              const nextCell = level.cells[nextRow][nextCol];
              if (
                nextCell === level.types.empty ||
                nextCell === level.types.goal
              ) {
                level.moveEntity(
                  { row: newRow, col: newCol },
                  { row: nextRow, col: nextCol }
                );
                level.moveEntity(this.pos, { row: newRow, col: newCol });
                this.pos = { row: newRow, col: newCol };
              }
              break;
          }
        }

        draw(ctx, grid) {
          const row = this.pos.row;
          const col = this.pos.col;
          ctx.fillStyle = "black";
          ctx.beginPath();
          ctx.arc(
            (col + 0.5) * grid,
            (row + 0.3) * grid,
            grid * 0.125,
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.fillRect(
            (col + 0.48) * grid,
            (row + 0.3) * grid,
            grid * 0.04,
            grid / 2.5
          );
          ctx.fillRect(
            (col + 0.3) * grid,
            (row + 0.5) * grid,
            grid / 2.5,
            grid * 0.04
          );
          ctx.moveTo((col + 0.5) * grid, (row + 0.7) * grid);
          ctx.lineTo((col + 0.65) * grid, (row + 0.9) * grid);
          ctx.moveTo((col + 0.5) * grid, (row + 0.7) * grid);
          ctx.lineTo((col + 0.35) * grid, (row + 0.9) * grid);
          ctx.stroke();
        }
      }

      // -------------------------
      // Lớp Game: Quản lý canvas, responsive, vòng lặp và sự kiện (bàn phím & touch)
      // -------------------------
      class Game {
        constructor(canvasId, levelString, onLevelComplete) {
          this.canvas = document.getElementById(canvasId);
          this.context = this.canvas.getContext("2d");
          this.level = new Level(levelString, 64);
          this.player = new Player(this.level.playerStart);
          this.playerDir = { row: 0, col: 0 };
          this.onLevelComplete = onLevelComplete;
          this.rAF = null;
          // Dành cho touch
          this.touchStartX = 0;
          this.touchStartY = 0;
          // Các đối tượng cache cho vẽ
          this.wallCanvas = null; // dùng để vẽ tường
          this.staticLayer = null; // lớp tĩnh (walls & goal)

          this.updateDimensions();
          this.bindEvents();
          window.addEventListener("resize", this.updateDimensions.bind(this));
        }

        updateDimensions() {
          const availableWidth = window.innerWidth;
          const availableHeight = window.innerHeight;
          this.canvas.width = availableWidth;
          this.canvas.height = availableHeight;
          const cols = this.level.width;
          const rows = this.level.cells.length;
          this.level.grid = Math.floor(
            Math.min(availableWidth / cols, availableHeight / rows)
          );
          this.grid = this.level.grid;
          //   this.canvas.width = cols * this.grid;
          //   this.canvas.height = rows * this.grid;
          this.wallCanvas = this.createWallCanvas();
          this.staticLayer = this.level.createStaticLayer(
            this.grid,
            this.wallCanvas
          );
        }

        createWallCanvas() {
          const wallCanvas = document.createElement("canvas");
          wallCanvas.width = wallCanvas.height = this.grid;
          const wallCtx = wallCanvas.getContext("2d");
          wallCtx.fillStyle = "#5b5530";
          wallCtx.fillRect(0, 0, this.grid, this.grid);
          wallCtx.fillStyle = "#a19555";
          wallCtx.fillRect(1, 1, this.grid - 2, this.grid * 0.3);
          wallCtx.fillRect(
            0,
            this.grid * 0.36,
            this.grid * 0.3,
            this.grid * 0.28
          );
          wallCtx.fillRect(
            this.grid * 0.36,
            this.grid * 0.36,
            this.grid * 0.65,
            this.grid * 0.28
          );
          wallCtx.fillRect(
            0,
            this.grid * 0.68,
            this.grid * 0.65,
            this.grid * 0.3
          );
          wallCtx.fillRect(
            this.grid * 0.7,
            this.grid * 0.68,
            this.grid * 0.3,
            this.grid * 0.3
          );
          return wallCanvas;
        }

        bindEvents() {
          // Bàn phím (desktop)
          document.addEventListener("keydown", (e) => {
            this.playerDir = { row: 0, col: 0 };
            switch (e.which) {
              case 37:
                this.playerDir.col = -1;
                break;
              case 38:
                this.playerDir.row = -1;
                break;
              case 39:
                this.playerDir.col = 1;
                break;
              case 40:
                this.playerDir.row = 1;
                break;
            }
          });
          // Touch (mobile)
          this.canvas.addEventListener("touchstart", (e) => {
            const touch = e.touches[0];
            this.touchStartX = touch.clientX;
            this.touchStartY = touch.clientY;
          });
          this.canvas.addEventListener("touchend", (e) => {
            const touch = e.changedTouches[0];
            const dx = touch.clientX - this.touchStartX;
            const dy = touch.clientY - this.touchStartY;
            this.playerDir = { row: 0, col: 0 };
            if (Math.abs(dx) > Math.abs(dy)) {
              if (dx > 30) this.playerDir.col = 1;
              else if (dx < -30) this.playerDir.col = -1;
            } else {
              if (dy > 30) this.playerDir.row = 1;
              else if (dy < -30) this.playerDir.row = -1;
            }
          });
          this.canvas.addEventListener("touchmove", (e) => {
            e.preventDefault();
          });
        }

        showWin() {
          cancelAnimationFrame(this.rAF);
          this.context.fillStyle = "black";
          this.context.globalAlpha = 0.75;
          this.context.fillRect(
            0,
            this.canvas.height / 2 - 30,
            this.canvas.width,
            60
          );
          this.context.globalAlpha = 1;
          this.context.fillStyle = "white";
          this.context.font = `${Math.floor(this.grid * 0.5)}px monospace`;
          this.context.textAlign = "center";
          this.context.textBaseline = "middle";
          this.context.fillText(
            "YOU WIN!",
            this.canvas.width / 2,
            this.canvas.height / 2
          );
          setTimeout(() => {
            this.onLevelComplete();
          }, 1000);
        }

        loop() {
          this.rAF = requestAnimationFrame(() => this.loop());
          this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.context.drawImage(this.staticLayer, 0, 0);
          this.level.drawDynamic(this.context, this.grid);
          this.player.draw(this.context, this.grid);
          if (this.level.isComplete()) {
            this.showWin();
          }
          if (this.playerDir.row !== 0 || this.playerDir.col !== 0) {
            this.player.move(this.playerDir, this.level);
            this.playerDir = { row: 0, col: 0 };
          }
        }

        start() {
          this.loop();
        }

        stop() {
          cancelAnimationFrame(this.rAF);
        }
      }

      // -------------------------
      // Quản lý game: khởi tạo game mới và chuyển level tự động
      // -------------------------
      let currentLevelIndex = 0;
      let game = null;

      function startGame(levelIndex) {
        if (game) game.stop();
        game = new Game("game", levels[levelIndex], () => {
          if (currentLevelIndex < levels.length - 1) {
            currentLevelIndex++;
            startGame(currentLevelIndex);
          } else {
            alert("Bạn đã hoàn thành tất cả các level!");
          }
        });
        game.start();
      }

      // Khởi chạy game với level đầu tiên
      startGame(currentLevelIndex);
    </script>
  </body>
</html>
